// Code generated by protoc-gen-go. DO NOT EDIT.
// source: profile.proto

/*
Package profile is a generated protocol buffer package.

It is generated from these files:
	profile.proto

It has these top-level messages:
	ServiceProfile
	RetryBudget
	RequestClass
	ResponseClass
	RequestMatch
	ResponseMatch
	HttpStatusRange
*/
package profile

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/duration"
import io_linkerd_proxy_http_types "github.com/linkerd/linkerd2-proxy-api/go/http_types"
import io_linkerd_proxy_destination "github.com/linkerd/linkerd2-proxy-api/go/destination"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ServiceProfile struct {
	// A list of request classes, each with a RequestMatch.  If a request matches
	// more than one RequestClass, the first match wins.
	RequestClasses []*RequestClass `protobuf:"bytes,1,rep,name=request_classes,json=requestClasses" json:"request_classes,omitempty"`
	// Retry budget describes how much additional load is acceptable to send to
	// this service from retries.
	RetryBudget         *RetryBudget              `protobuf:"bytes,2,opt,name=retry_budget,json=retryBudget" json:"retry_budget,omitempty"`
	DefaultRetryTimeout *google_protobuf.Duration `protobuf:"bytes,3,opt,name=default_retry_timeout,json=defaultRetryTimeout" json:"default_retry_timeout,omitempty"`
}

func (m *ServiceProfile) Reset()                    { *m = ServiceProfile{} }
func (m *ServiceProfile) String() string            { return proto.CompactTextString(m) }
func (*ServiceProfile) ProtoMessage()               {}
func (*ServiceProfile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ServiceProfile) GetRequestClasses() []*RequestClass {
	if m != nil {
		return m.RequestClasses
	}
	return nil
}

func (m *ServiceProfile) GetRetryBudget() *RetryBudget {
	if m != nil {
		return m.RetryBudget
	}
	return nil
}

func (m *ServiceProfile) GetDefaultRetryTimeout() *google_protobuf.Duration {
	if m != nil {
		return m.DefaultRetryTimeout
	}
	return nil
}

type RetryBudget struct {
	// The maximum ratio of retries to non-retry requests.  For example if this
	// value is 0.2 then the number of retries is at most 20% of the number of
	// non-retry requests.  This can be thought of as the amount of extra load
	// added by retries (e.g. 20% extra load).
	MaxRetryRatio float32 `protobuf:"fixed32,1,opt,name=max_retry_ratio,json=maxRetryRatio" json:"max_retry_ratio,omitempty"`
	// The duration over which the retry budget is calculated.  For example, if
	// this value is 10 seconds, then in the past 10 seconds it must be true that:
	//
	// #retries <= #requests*max_retry_ratio + additional_retries_per_second*10
	//
	// Increasing the duration over which this is calculated allows for larger
	// bursts of retries.
	Ttl *google_protobuf.Duration `protobuf:"bytes,2,opt,name=ttl" json:"ttl,omitempty"`
	// This amount of retries per second are allowed in addition to the ones
	// allowed by the max_retry_ratio.  This is to allow retries to happen even
	// when the request rate is low.
	AdditionalRetriesPerSecond uint32 `protobuf:"varint,3,opt,name=additional_retries_per_second,json=additionalRetriesPerSecond" json:"additional_retries_per_second,omitempty"`
}

func (m *RetryBudget) Reset()                    { *m = RetryBudget{} }
func (m *RetryBudget) String() string            { return proto.CompactTextString(m) }
func (*RetryBudget) ProtoMessage()               {}
func (*RetryBudget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RetryBudget) GetMaxRetryRatio() float32 {
	if m != nil {
		return m.MaxRetryRatio
	}
	return 0
}

func (m *RetryBudget) GetTtl() *google_protobuf.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

func (m *RetryBudget) GetAdditionalRetriesPerSecond() uint32 {
	if m != nil {
		return m.AdditionalRetriesPerSecond
	}
	return 0
}

type RequestClass struct {
	// This class contains requests which match this condition.
	Condition *RequestMatch `protobuf:"bytes,1,opt,name=condition" json:"condition,omitempty"`
	// A list of response classes for this request class.  If a response matches
	// more than one ResponseClass, the first match wins.  If a response does not
	// match any ResponseClasses, it is considered to be a successful response.
	ResponseClasses []*ResponseClass `protobuf:"bytes,2,rep,name=response_classes,json=responseClasses" json:"response_classes,omitempty"`
	// After this duration has elapsed since the initial request, no more retries
	// will be attempted.  If unspecified, this defaults to the service profile's
	// default_retry_timeout.
	RetryTimeout *google_protobuf.Duration `protobuf:"bytes,3,opt,name=retry_timeout,json=retryTimeout" json:"retry_timeout,omitempty"`
}

func (m *RequestClass) Reset()                    { *m = RequestClass{} }
func (m *RequestClass) String() string            { return proto.CompactTextString(m) }
func (*RequestClass) ProtoMessage()               {}
func (*RequestClass) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RequestClass) GetCondition() *RequestMatch {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *RequestClass) GetResponseClasses() []*ResponseClass {
	if m != nil {
		return m.ResponseClasses
	}
	return nil
}

func (m *RequestClass) GetRetryTimeout() *google_protobuf.Duration {
	if m != nil {
		return m.RetryTimeout
	}
	return nil
}

type ResponseClass struct {
	// This class contains responses which match this condition.
	Condition *ResponseMatch `protobuf:"bytes,1,opt,name=condition" json:"condition,omitempty"`
	// If responses in this class should be considered failures.
	IsFailure bool `protobuf:"varint,2,opt,name=is_failure,json=isFailure" json:"is_failure,omitempty"`
	// If responses in this class are safe to retry.
	IsRetryable bool `protobuf:"varint,3,opt,name=is_retryable,json=isRetryable" json:"is_retryable,omitempty"`
}

func (m *ResponseClass) Reset()                    { *m = ResponseClass{} }
func (m *ResponseClass) String() string            { return proto.CompactTextString(m) }
func (*ResponseClass) ProtoMessage()               {}
func (*ResponseClass) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ResponseClass) GetCondition() *ResponseMatch {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *ResponseClass) GetIsFailure() bool {
	if m != nil {
		return m.IsFailure
	}
	return false
}

func (m *ResponseClass) GetIsRetryable() bool {
	if m != nil {
		return m.IsRetryable
	}
	return false
}

type RequestMatch struct {
	// Types that are valid to be assigned to Match:
	//	*RequestMatch_All
	//	*RequestMatch_Any
	//	*RequestMatch_Not
	//	*RequestMatch_Path
	//	*RequestMatch_Method
	Match isRequestMatch_Match `protobuf_oneof:"match"`
}

func (m *RequestMatch) Reset()                    { *m = RequestMatch{} }
func (m *RequestMatch) String() string            { return proto.CompactTextString(m) }
func (*RequestMatch) ProtoMessage()               {}
func (*RequestMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isRequestMatch_Match interface{ isRequestMatch_Match() }

type RequestMatch_All struct {
	All *RequestMatch_Seq `protobuf:"bytes,1,opt,name=all,oneof"`
}
type RequestMatch_Any struct {
	Any *RequestMatch_Seq `protobuf:"bytes,2,opt,name=any,oneof"`
}
type RequestMatch_Not struct {
	Not *RequestMatch `protobuf:"bytes,3,opt,name=not,oneof"`
}
type RequestMatch_Path struct {
	Path string `protobuf:"bytes,4,opt,name=path,oneof"`
}
type RequestMatch_Method struct {
	Method *io_linkerd_proxy_http_types.HttpMethod `protobuf:"bytes,5,opt,name=method,oneof"`
}

func (*RequestMatch_All) isRequestMatch_Match()    {}
func (*RequestMatch_Any) isRequestMatch_Match()    {}
func (*RequestMatch_Not) isRequestMatch_Match()    {}
func (*RequestMatch_Path) isRequestMatch_Match()   {}
func (*RequestMatch_Method) isRequestMatch_Match() {}

func (m *RequestMatch) GetMatch() isRequestMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RequestMatch) GetAll() *RequestMatch_Seq {
	if x, ok := m.GetMatch().(*RequestMatch_All); ok {
		return x.All
	}
	return nil
}

func (m *RequestMatch) GetAny() *RequestMatch_Seq {
	if x, ok := m.GetMatch().(*RequestMatch_Any); ok {
		return x.Any
	}
	return nil
}

func (m *RequestMatch) GetNot() *RequestMatch {
	if x, ok := m.GetMatch().(*RequestMatch_Not); ok {
		return x.Not
	}
	return nil
}

func (m *RequestMatch) GetPath() string {
	if x, ok := m.GetMatch().(*RequestMatch_Path); ok {
		return x.Path
	}
	return ""
}

func (m *RequestMatch) GetMethod() *io_linkerd_proxy_http_types.HttpMethod {
	if x, ok := m.GetMatch().(*RequestMatch_Method); ok {
		return x.Method
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RequestMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RequestMatch_OneofMarshaler, _RequestMatch_OneofUnmarshaler, _RequestMatch_OneofSizer, []interface{}{
		(*RequestMatch_All)(nil),
		(*RequestMatch_Any)(nil),
		(*RequestMatch_Not)(nil),
		(*RequestMatch_Path)(nil),
		(*RequestMatch_Method)(nil),
	}
}

func _RequestMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RequestMatch)
	// match
	switch x := m.Match.(type) {
	case *RequestMatch_All:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *RequestMatch_Any:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *RequestMatch_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *RequestMatch_Path:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Path)
	case *RequestMatch_Method:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Method); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RequestMatch.Match has unexpected type %T", x)
	}
	return nil
}

func _RequestMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RequestMatch)
	switch tag {
	case 1: // match.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_All{msg}
		return true, err
	case 2: // match.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Any{msg}
		return true, err
	case 3: // match.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatch)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Not{msg}
		return true, err
	case 4: // match.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Match = &RequestMatch_Path{x}
		return true, err
	case 5: // match.method
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(io_linkerd_proxy_http_types.HttpMethod)
		err := b.DecodeMessage(msg)
		m.Match = &RequestMatch_Method{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RequestMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RequestMatch)
	// match
	switch x := m.Match.(type) {
	case *RequestMatch_All:
		s := proto.Size(x.All)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Any:
		s := proto.Size(x.Any)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Not:
		s := proto.Size(x.Not)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestMatch_Path:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Path)))
		n += len(x.Path)
	case *RequestMatch_Method:
		s := proto.Size(x.Method)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RequestMatch_Seq struct {
	Matches []*RequestMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
}

func (m *RequestMatch_Seq) Reset()                    { *m = RequestMatch_Seq{} }
func (m *RequestMatch_Seq) String() string            { return proto.CompactTextString(m) }
func (*RequestMatch_Seq) ProtoMessage()               {}
func (*RequestMatch_Seq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *RequestMatch_Seq) GetMatches() []*RequestMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

type ResponseMatch struct {
	// Types that are valid to be assigned to Match:
	//	*ResponseMatch_All
	//	*ResponseMatch_Any
	//	*ResponseMatch_Not
	//	*ResponseMatch_Status
	Match isResponseMatch_Match `protobuf_oneof:"match"`
}

func (m *ResponseMatch) Reset()                    { *m = ResponseMatch{} }
func (m *ResponseMatch) String() string            { return proto.CompactTextString(m) }
func (*ResponseMatch) ProtoMessage()               {}
func (*ResponseMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isResponseMatch_Match interface{ isResponseMatch_Match() }

type ResponseMatch_All struct {
	All *ResponseMatch_Seq `protobuf:"bytes,1,opt,name=all,oneof"`
}
type ResponseMatch_Any struct {
	Any *ResponseMatch_Seq `protobuf:"bytes,2,opt,name=any,oneof"`
}
type ResponseMatch_Not struct {
	Not *ResponseMatch `protobuf:"bytes,3,opt,name=not,oneof"`
}
type ResponseMatch_Status struct {
	Status *HttpStatusRange `protobuf:"bytes,4,opt,name=status,oneof"`
}

func (*ResponseMatch_All) isResponseMatch_Match()    {}
func (*ResponseMatch_Any) isResponseMatch_Match()    {}
func (*ResponseMatch_Not) isResponseMatch_Match()    {}
func (*ResponseMatch_Status) isResponseMatch_Match() {}

func (m *ResponseMatch) GetMatch() isResponseMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ResponseMatch) GetAll() *ResponseMatch_Seq {
	if x, ok := m.GetMatch().(*ResponseMatch_All); ok {
		return x.All
	}
	return nil
}

func (m *ResponseMatch) GetAny() *ResponseMatch_Seq {
	if x, ok := m.GetMatch().(*ResponseMatch_Any); ok {
		return x.Any
	}
	return nil
}

func (m *ResponseMatch) GetNot() *ResponseMatch {
	if x, ok := m.GetMatch().(*ResponseMatch_Not); ok {
		return x.Not
	}
	return nil
}

func (m *ResponseMatch) GetStatus() *HttpStatusRange {
	if x, ok := m.GetMatch().(*ResponseMatch_Status); ok {
		return x.Status
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResponseMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResponseMatch_OneofMarshaler, _ResponseMatch_OneofUnmarshaler, _ResponseMatch_OneofSizer, []interface{}{
		(*ResponseMatch_All)(nil),
		(*ResponseMatch_Any)(nil),
		(*ResponseMatch_Not)(nil),
		(*ResponseMatch_Status)(nil),
	}
}

func _ResponseMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResponseMatch)
	// match
	switch x := m.Match.(type) {
	case *ResponseMatch_All:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *ResponseMatch_Any:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *ResponseMatch_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *ResponseMatch_Status:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Status); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResponseMatch.Match has unexpected type %T", x)
	}
	return nil
}

func _ResponseMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResponseMatch)
	switch tag {
	case 1: // match.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_All{msg}
		return true, err
	case 2: // match.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseMatch_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_Any{msg}
		return true, err
	case 3: // match.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseMatch)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_Not{msg}
		return true, err
	case 4: // match.status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpStatusRange)
		err := b.DecodeMessage(msg)
		m.Match = &ResponseMatch_Status{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResponseMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResponseMatch)
	// match
	switch x := m.Match.(type) {
	case *ResponseMatch_All:
		s := proto.Size(x.All)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseMatch_Any:
		s := proto.Size(x.Any)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseMatch_Not:
		s := proto.Size(x.Not)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseMatch_Status:
		s := proto.Size(x.Status)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ResponseMatch_Seq struct {
	Matches []*ResponseMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
}

func (m *ResponseMatch_Seq) Reset()                    { *m = ResponseMatch_Seq{} }
func (m *ResponseMatch_Seq) String() string            { return proto.CompactTextString(m) }
func (*ResponseMatch_Seq) ProtoMessage()               {}
func (*ResponseMatch_Seq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *ResponseMatch_Seq) GetMatches() []*ResponseMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

// If either a minimum or maximum is not specified, the range is considered to be
// over a discrete value.
type HttpStatusRange struct {
	// Types that are valid to be assigned to Match:
	//	*HttpStatusRange_Min
	//	*HttpStatusRange_Max
	Match isHttpStatusRange_Match `protobuf_oneof:"match"`
}

func (m *HttpStatusRange) Reset()                    { *m = HttpStatusRange{} }
func (m *HttpStatusRange) String() string            { return proto.CompactTextString(m) }
func (*HttpStatusRange) ProtoMessage()               {}
func (*HttpStatusRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isHttpStatusRange_Match interface{ isHttpStatusRange_Match() }

type HttpStatusRange_Min struct {
	Min uint32 `protobuf:"varint,1,opt,name=min,oneof"`
}
type HttpStatusRange_Max struct {
	Max uint32 `protobuf:"varint,2,opt,name=max,oneof"`
}

func (*HttpStatusRange_Min) isHttpStatusRange_Match() {}
func (*HttpStatusRange_Max) isHttpStatusRange_Match() {}

func (m *HttpStatusRange) GetMatch() isHttpStatusRange_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HttpStatusRange) GetMin() uint32 {
	if x, ok := m.GetMatch().(*HttpStatusRange_Min); ok {
		return x.Min
	}
	return 0
}

func (m *HttpStatusRange) GetMax() uint32 {
	if x, ok := m.GetMatch().(*HttpStatusRange_Max); ok {
		return x.Max
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpStatusRange) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpStatusRange_OneofMarshaler, _HttpStatusRange_OneofUnmarshaler, _HttpStatusRange_OneofSizer, []interface{}{
		(*HttpStatusRange_Min)(nil),
		(*HttpStatusRange_Max)(nil),
	}
}

func _HttpStatusRange_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpStatusRange)
	// match
	switch x := m.Match.(type) {
	case *HttpStatusRange_Min:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Min))
	case *HttpStatusRange_Max:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Max))
	case nil:
	default:
		return fmt.Errorf("HttpStatusRange.Match has unexpected type %T", x)
	}
	return nil
}

func _HttpStatusRange_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpStatusRange)
	switch tag {
	case 1: // match.min
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Match = &HttpStatusRange_Min{uint32(x)}
		return true, err
	case 2: // match.max
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Match = &HttpStatusRange_Max{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _HttpStatusRange_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpStatusRange)
	// match
	switch x := m.Match.(type) {
	case *HttpStatusRange_Min:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Min))
	case *HttpStatusRange_Max:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Max))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ServiceProfile)(nil), "io.linkerd.proxy.profile.ServiceProfile")
	proto.RegisterType((*RetryBudget)(nil), "io.linkerd.proxy.profile.RetryBudget")
	proto.RegisterType((*RequestClass)(nil), "io.linkerd.proxy.profile.RequestClass")
	proto.RegisterType((*ResponseClass)(nil), "io.linkerd.proxy.profile.ResponseClass")
	proto.RegisterType((*RequestMatch)(nil), "io.linkerd.proxy.profile.RequestMatch")
	proto.RegisterType((*RequestMatch_Seq)(nil), "io.linkerd.proxy.profile.RequestMatch.Seq")
	proto.RegisterType((*ResponseMatch)(nil), "io.linkerd.proxy.profile.ResponseMatch")
	proto.RegisterType((*ResponseMatch_Seq)(nil), "io.linkerd.proxy.profile.ResponseMatch.Seq")
	proto.RegisterType((*HttpStatusRange)(nil), "io.linkerd.proxy.profile.HttpStatusRange")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Profile service

type ProfileClient interface {
	// Given a destination, return that service's profile and send an update
	// whenever it changes.
	Get(ctx context.Context, in *io_linkerd_proxy_destination.GetDestination, opts ...grpc.CallOption) (Profile_GetClient, error)
}

type profileClient struct {
	cc *grpc.ClientConn
}

func NewProfileClient(cc *grpc.ClientConn) ProfileClient {
	return &profileClient{cc}
}

func (c *profileClient) Get(ctx context.Context, in *io_linkerd_proxy_destination.GetDestination, opts ...grpc.CallOption) (Profile_GetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Profile_serviceDesc.Streams[0], c.cc, "/io.linkerd.proxy.profile.Profile/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &profileGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Profile_GetClient interface {
	Recv() (*ServiceProfile, error)
	grpc.ClientStream
}

type profileGetClient struct {
	grpc.ClientStream
}

func (x *profileGetClient) Recv() (*ServiceProfile, error) {
	m := new(ServiceProfile)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Profile service

type ProfileServer interface {
	// Given a destination, return that service's profile and send an update
	// whenever it changes.
	Get(*io_linkerd_proxy_destination.GetDestination, Profile_GetServer) error
}

func RegisterProfileServer(s *grpc.Server, srv ProfileServer) {
	s.RegisterService(&_Profile_serviceDesc, srv)
}

func _Profile_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(io_linkerd_proxy_destination.GetDestination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProfileServer).Get(m, &profileGetServer{stream})
}

type Profile_GetServer interface {
	Send(*ServiceProfile) error
	grpc.ServerStream
}

type profileGetServer struct {
	grpc.ServerStream
}

func (x *profileGetServer) Send(m *ServiceProfile) error {
	return x.ServerStream.SendMsg(m)
}

var _Profile_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.linkerd.proxy.profile.Profile",
	HandlerType: (*ProfileServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Get",
			Handler:       _Profile_Get_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "profile.proto",
}

func init() { proto.RegisterFile("profile.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 716 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0xd3, 0x30,
	0x18, 0x6d, 0x9a, 0xfd, 0xba, 0xeb, 0x3a, 0x0c, 0x48, 0xa5, 0xd2, 0x50, 0xa9, 0xc4, 0x28, 0x8c,
	0xa5, 0x53, 0xb9, 0x03, 0x69, 0x63, 0xdd, 0x60, 0xbd, 0x99, 0x98, 0x5c, 0xae, 0xb8, 0xa9, 0xdc,
	0xe6, 0x6b, 0x6b, 0x91, 0xc4, 0x99, 0xed, 0xa0, 0xf6, 0x4d, 0x78, 0x01, 0x5e, 0x0d, 0xf1, 0x02,
	0xdc, 0x70, 0x85, 0x62, 0x27, 0x6b, 0xb6, 0xaa, 0x53, 0x7a, 0xd5, 0xfa, 0xcb, 0x39, 0xc7, 0x5f,
	0xce, 0xf9, 0x62, 0xa3, 0x72, 0x28, 0xf8, 0x88, 0x79, 0xe0, 0x84, 0x82, 0x2b, 0x8e, 0xab, 0x8c,
	0x3b, 0x1e, 0x0b, 0xbe, 0x83, 0x70, 0xe3, 0xca, 0x74, 0xe6, 0x24, 0xcf, 0x6b, 0xcf, 0xc7, 0x9c,
	0x8f, 0x3d, 0x68, 0x69, 0xdc, 0x20, 0x1a, 0xb5, 0xdc, 0x48, 0x50, 0xc5, 0x78, 0x60, 0x98, 0xb5,
	0xbd, 0x89, 0x52, 0x61, 0x5f, 0xcd, 0x42, 0x90, 0x49, 0xe5, 0x91, 0x0b, 0x52, 0xb1, 0x20, 0x03,
	0x6a, 0xfc, 0xb3, 0xd0, 0x6e, 0x0f, 0xc4, 0x0f, 0x36, 0x84, 0x6b, 0xa3, 0x8b, 0xbf, 0xa0, 0x8a,
	0x80, 0x9b, 0x08, 0xa4, 0xea, 0x0f, 0x3d, 0x2a, 0x25, 0xc8, 0xaa, 0x55, 0xb7, 0x9b, 0xa5, 0xf6,
	0x81, 0xb3, 0xac, 0x17, 0x87, 0x18, 0xc2, 0x79, 0x8c, 0x27, 0xbb, 0x22, 0xb3, 0x02, 0x89, 0xbb,
	0x68, 0x47, 0x80, 0x12, 0xb3, 0xfe, 0x20, 0x72, 0xc7, 0xa0, 0xaa, 0xc5, 0xba, 0xd5, 0x2c, 0xb5,
	0x5f, 0x3e, 0xa4, 0xa6, 0xc4, 0xac, 0xa3, 0xc1, 0xa4, 0x24, 0xe6, 0x0b, 0x7c, 0x85, 0x9e, 0xba,
	0x30, 0xa2, 0x91, 0xa7, 0xfa, 0x46, 0x51, 0x31, 0x1f, 0x78, 0xa4, 0xaa, 0xb6, 0x96, 0x7c, 0xe6,
	0x18, 0x4b, 0x9c, 0xd4, 0x12, 0xe7, 0x22, 0xb1, 0x84, 0x3c, 0x4e, 0x78, 0x5a, 0xfa, 0xab, 0x61,
	0x35, 0x7e, 0x59, 0xa8, 0x94, 0xd9, 0x0b, 0x1f, 0xa0, 0x8a, 0x4f, 0xa7, 0x89, 0xb4, 0x26, 0x56,
	0xad, 0xba, 0xd5, 0x2c, 0x92, 0xb2, 0x4f, 0xa7, 0x1a, 0x48, 0xe2, 0x22, 0x3e, 0x44, 0xb6, 0x52,
	0x5e, 0xf2, 0x1e, 0x0f, 0x6c, 0x1a, 0xa3, 0xf0, 0x19, 0xda, 0xa7, 0xae, 0xcb, 0xe2, 0x02, 0xf5,
	0xb4, 0x36, 0x03, 0xd9, 0x0f, 0x41, 0xf4, 0x25, 0x0c, 0x79, 0xe0, 0xea, 0xde, 0xcb, 0xa4, 0x36,
	0x07, 0x11, 0x83, 0xb9, 0x06, 0xd1, 0xd3, 0x88, 0xc6, 0x1f, 0x0b, 0xed, 0x64, 0x1d, 0xc6, 0x17,
	0x68, 0x3b, 0x7e, 0xa0, 0xf1, 0xba, 0xc5, 0x3c, 0xe1, 0x5c, 0x51, 0x35, 0x9c, 0x90, 0x39, 0x11,
	0x13, 0xb4, 0x27, 0x40, 0x86, 0x3c, 0x90, 0x70, 0x9b, 0x74, 0x51, 0x27, 0xfd, 0xea, 0x21, 0x31,
	0xc3, 0x30, 0x51, 0x57, 0x44, 0x76, 0x09, 0x12, 0x9f, 0xa0, 0xf2, 0x8a, 0xc9, 0x98, 0xd9, 0x48,
	0x23, 0xf9, 0x69, 0xa1, 0xf2, 0x9d, 0x2d, 0xf0, 0xa7, 0xc5, 0x77, 0xcd, 0xd1, 0xde, 0xc2, 0xcb,
	0xee, 0x23, 0xc4, 0x64, 0x7f, 0x44, 0x99, 0x17, 0x09, 0xd0, 0xd1, 0x6d, 0x91, 0x6d, 0x26, 0x3f,
	0x9b, 0x02, 0x7e, 0x81, 0x76, 0x98, 0x34, 0xc9, 0xd3, 0x81, 0x07, 0xba, 0xed, 0x2d, 0x52, 0x62,
	0x92, 0xa4, 0xa5, 0xc6, 0xdf, 0xe2, 0x6d, 0x0a, 0x5a, 0x1d, 0x9f, 0x20, 0x9b, 0x7a, 0x5e, 0xd2,
	0xd3, 0x9b, 0x7c, 0xfe, 0x3b, 0x3d, 0xb8, 0xe9, 0x16, 0x48, 0x4c, 0xd4, 0xfc, 0x60, 0x96, 0x8c,
	0xd1, 0xaa, 0xfc, 0x60, 0x86, 0xdf, 0x23, 0x3b, 0xe0, 0xa9, 0xc3, 0x39, 0xf3, 0x8f, 0xb9, 0x01,
	0x57, 0xf8, 0x09, 0x5a, 0x0b, 0xa9, 0x9a, 0x54, 0xd7, 0xea, 0x56, 0x73, 0xbb, 0x5b, 0x20, 0x7a,
	0x85, 0xcf, 0xd0, 0x86, 0x0f, 0x6a, 0xc2, 0xdd, 0xea, 0xfa, 0x32, 0xa3, 0x33, 0x87, 0x4a, 0x57,
	0xa9, 0xf0, 0x4a, 0xc3, 0xbb, 0x05, 0x92, 0x10, 0x6b, 0x97, 0xc8, 0xee, 0xc1, 0x0d, 0xfe, 0x88,
	0x36, 0xfd, 0x78, 0xbf, 0x15, 0x0e, 0x0f, 0x13, 0x59, 0x4a, 0xeb, 0x6c, 0xa2, 0x75, 0xfd, 0xb7,
	0xf1, 0xbb, 0x38, 0x1f, 0x09, 0x63, 0xfc, 0x69, 0xd6, 0xf8, 0xc3, 0x9c, 0xc3, 0x90, 0x75, 0xfe,
	0x34, 0xeb, 0xfc, 0xca, 0x02, 0xc1, 0x0c, 0x7f, 0xc8, 0x5a, 0x9f, 0x77, 0x1c, 0x53, 0xef, 0xcf,
	0xd1, 0x86, 0x54, 0x54, 0x45, 0x52, 0xbb, 0x5f, 0x6a, 0xbf, 0x5e, 0xce, 0x8f, 0x2d, 0xee, 0x69,
	0x2c, 0xa1, 0xc1, 0x18, 0x62, 0x9f, 0x0d, 0xb5, 0xd6, 0x35, 0x3e, 0x9f, 0xdd, 0xf7, 0x39, 0xf7,
	0xb7, 0xb1, 0x68, 0x74, 0x07, 0x55, 0xee, 0xed, 0x87, 0x31, 0xb2, 0x7d, 0x66, 0x3e, 0xbb, 0x72,
	0xdc, 0xbe, 0xcf, 0x02, 0x5d, 0xa3, 0x53, 0x6d, 0x9e, 0xa9, 0xd1, 0xe9, 0xad, 0x46, 0xdb, 0x43,
	0x9b, 0xe9, 0x3d, 0x42, 0x91, 0x7d, 0x09, 0x0a, 0xbf, 0x5d, 0x6c, 0x28, 0x7b, 0x0d, 0x5d, 0x82,
	0xba, 0x98, 0x2f, 0x6b, 0xcd, 0xe5, 0xed, 0xdf, 0xbd, 0xa6, 0x1a, 0x85, 0x63, 0xab, 0xd3, 0xfe,
	0x76, 0x3c, 0x66, 0x6a, 0x12, 0x0d, 0x9c, 0x21, 0xf7, 0x5b, 0x09, 0x2d, 0xfd, 0x6d, 0x1f, 0x69,
	0xfe, 0x11, 0x0d, 0x59, 0x6b, 0xcc, 0x5b, 0x89, 0xcc, 0x60, 0x43, 0x1f, 0x41, 0xef, 0xfe, 0x07,
	0x00, 0x00, 0xff, 0xff, 0x7c, 0xd4, 0xc8, 0x56, 0x68, 0x07, 0x00, 0x00,
}
